package lectures.week2oop

object Generics extends App {
  // ====================================обобщения (Generics)==========================================
  // с целью возможности замены типов данных в методах, существуют обобщения
  // обобщения - это такая штука, которая позволит использовать один и тот же код для разных типов данных
  // для написания универсальной функции в качестве типа данных нужно указать "обобщенный" тип данных
  //         (любая заглавная буква латинского алфавита) в квадратных скобках после названия метода
  // например вот так
  def createElement[A](el : A) : A = el
  // теперь в качестве el можно передать значения любого вида
  println(createElement("String"))
  println(createElement(2))

  // также обобщенные типы данных можно использовать при создании класса
  // и вписать необходимые типы данных в процессе инициализации нового экземпляра класса

  class SomeClass[B, C] {
    def someFunc(fEl : B, sEl : C) : Unit = println(s"first is ${fEl.getClass.getSimpleName}, second is ${sEl.getClass.getSimpleName}")
  }
  val aVar = new SomeClass[Int, String]
  aVar.someFunc(2, "2")

  // =========================================ограничения типов при обощении===========================
  // разбирать будем на иерархии классов, следующей ниже:
  //                                              Thing
  //                                                |
  //                                             Vehicle
  //                                        |------------------|
  //                                      Car               Bicycle
  //                        |-------------|---------|             |
  //                 Ambulance          Taxi      Jeep        Tricycle

  trait Thing
  class Vehicle extends Thing
  class Car extends Vehicle
  class Ambulance extends Car
  class Taxi extends Car
  class Jeep extends Car
  class Bicycle extends Vehicle
  class Tricycle extends Bicycle

  // далее пропишем класс Parking
  class Parking[T](val vehicle: T)

  // при объявлениии обобщенного класса в качестве обощения, помимо класса передаваемого параметра
  // можно передать и его родительский(или выше по цепочке) класс
  // например можно в качестве параметра передать класс Taxi, а в качестве обощения передать класс Taxi
  val testParentClass = new Parking[Car](new Taxi)
  println("The line above works")


  // для того чтобы ограничить возможные обобщения существует ограничение типов
  // верхнее ограничение <:
  // нижнее ограничение >:

  // ВЕРХНЕЕ ограничение означает что в качестве обощенного класса могут быть использованы
  // только классы идущие НИЖЕ по иерархии (то есть ограничиваем верх)
  // Parking[T <: Vehicle] будет означать, что в качестве T можно использовать либо сам класс Vegicle
  // либо его подклассы Car, Ambulance, Taxi, Jeep и Bicycle, Tricycle

  // НИЖНЕЕ ограничение означает что мы ограничиваем низ иерархии
  // то есть в качестве обобщенного класса могут быть использованы только классы
  // стоящие ВВЕРХ по иерархческой цепочке
  // Parking[T >: Bicycle] - означает что в качестве T можно использовать сам Bicycle либо родитель вверх по цепи
  // Bicycle, Vehicle, Thing

  // Так же можно ограничивать с двух сторон
  // сперва нужно ограничить снизу
  //class Parking[T >: Bicycle <: Vehicle]


  //======================================вариативность (variance problem)=========================================

  // разбираться будем на родительском классе Fruit и дочерними классами Aplle и Banana
  class Fruit
  class Apple extends Fruit
  class Banana extends Fruit

  //------------------Инвариантность(Invariance)
  // инвариантность диктует, что List[Apple] и List[Fruit] это соверщенно разные вещи не связанные никакими
  // родственными связями. Тип в скобках без каких-либо дополнительных знаков, свидетельствует об
  // инвариантности
  class InvariantList[A]
  val invariantFruitList : InvariantList[Fruit] = new InvariantList[Fruit]
  // т.е. тип указанный слева должен совпадать с типом в правой части



  //------------------Контрвариантность(Contravariance)
  // Контрвариантность предполагает знак МИНУС перед обобщенным типом данных
  // контрвариантность означает что ЭКЗЕМПЛЯР класса может иметь РОДИТЕЛЬСКИЙ класс указанного при определении
  class ContravariantList[-B]
  val contravariantList : ContravariantList[Apple] = new ContravariantList[Fruit]



  //------------------Ковариантность(Covariance)
  // ковариантность предпологает знак ПЛЮС перед обобщенным типом данных
  // ковариантность означает что ЭКЗЕМПЛЯР класса может иметь ПОДклассы указанного при определении
  class CovariantList[+C]
  val covarianttList : CovariantList[Fruit] = new CovariantList[Apple]







}
